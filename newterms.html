<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
      <link rel="stylesheet" type="text/css" href="styles.css">
   </head>
   <body>

      <ul class="navbar">
         <!-- <li class="navbarList"><a href="#home">Home</a></li>
         <li class="navbarList"><a href="#news">News</a></li> -->
         

         <li class="dropdown">
            <a href="javascript:void(0)" class="dropbtn">Home</a>
            <div class="dropdown-content">
   
               <a href="https://cmparks10.github.io/Cheat-Sheet-Page/newterms.html">github</a>
            </div>
         </li>
   
         <li class="dropdown">
            <a href="javascript:void(0)" class="dropbtn">New Stuff to Learn</a>
            <div class="dropdown-content">
   
               <a href="https://cmparks10.github.io/Cheat-Sheet-Page/newterms.html">github</a>
            </div>
         </li>
   
   
         <li class="dropdown">
            <a href="javascript:void(0)" class="dropbtn">System Design and Higher Level Questions</a>
            <div class="dropdown-content">
   
               <a href="https://cmparks10.github.io/Cheat-Sheet-Page/design.html">Github</a>
            </div>
         </li>
   
     </ul>

      <h2>Aspect Oriented Programming</h2>
      <h2>VDOM</h2>
      <h2>Test Driven Development</h2>
      <li>
         <a href="https://www.browserstack.com/guide/what-is-test-driven-development">What is TDD</a>
         <ul>
            <li>Write Unit Tests before developing code.</li>
            <li>Agile-born <b>iterative</b> approach</li>
            <li>Three phases: Write Tests, Correct the Code, Refactor the code.</li>
            <li>TDD is built around providing feedback at early stages, allowing Feedback Driven Development, allowing adaptability to changing requirements from the client.</li>
            <li>JUnit is the Java used testing tool/framework. Each language has their own.</li>
         </ul>
      </li>
      <h2>Behavior Driven Development</h2>
      <li>
         <a href="https://www.browserstack.com/guide/what-is-bdd-testing"></a>
         <ul>
            <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">wikipedia BDD</a>
            <li>Naming software tests using <b>domain</b> language to describe the behavior of code. </li>
            <li>Domain Specific Language, or <b>DSL</b> combined with natural language constructs (english)</li>
            <li>Uses domain specific language using natural language constructs that an express the behavior and the expected outcomes</li>
            <li>"Feature Files" are written in Gherkin, a syntax used to allow tools like Cucubmer to validate behaviors. Used to write Given/When/Then statements</li>
            <li>Title, Narrative, and Acceptance Criteria, Feature, Description</li>
            <li>Feature Files, Runners, Step Definitions</li>
            <li>Also referred to as "Specification by Example"</li>
         </ul>
      </li>
      <h2>Domain Driven Design</h2>
      <p>Domain-Driven Design (DDD) is a software development approach that focuses on creating software that closely aligns with a particular business domain. It emphasizes understanding the domain's intricacies and complexities through close collaboration with domain experts. This understanding is then translated into a software model that reflects the domain's concepts and rules.</p>
      <h3>Key Aspects of DDD</h3>
      <ul>
         <li><strong>Ubiquitous Language:</strong> DDD promotes a shared vocabulary between developers and domain experts. This common understanding helps ensure everyone is on the same page about the system's functionality and behavior.</li>
         <li><strong>Domain Model:</strong> DDD centers around creating a domain model, a set of abstractions that capture the core entities, processes, and rules of the domain. This model serves as the foundation for the software design.</li>
         <li><strong>Bounded Contexts:</strong> DDD acknowledges that complex systems can be broken down into smaller, more manageable subdomains. These subdomains, called bounded contexts, each have their own domain model that reflects their specific focus.</li>
      </ul>
      <h3>DDD Toolbox</h3>
      <p>DDD provides a toolbox of concepts and patterns for building these domain models. Some common ones include:</p>
      <ul>
         <li><strong>Entities:</strong> Objects that have a unique identity and a lifecycle. For instance, in an e-commerce system, a "Product" could be an entity.</li>
         <li><strong>Value Objects:</strong> Objects that don't have a unique identity but encapsulate a specific value. An example might be an "Address" within an order system.</li>
         <li><strong>Aggregates:</strong> Groups of entities and value objects that are treated as a single unit. This helps manage data consistency.</li>
         <li><strong>Domain Services:</strong> Classes that encapsulate complex business logic that doesn't neatly fit within an entity or value object.</li>
      </ul>
      <h3>Benefits of DDD</h3>
      <p>By following these principles and leveraging these patterns, DDD aims to produce software that is:</p>
      <ul>
         <li><strong>More maintainable:</strong> The code reflects the domain concepts, making it easier to understand and modify.</li>
         <li><strong>More adaptable:</strong> The focus on bounded contexts allows for easier evolution of the system as business needs change.</li>
         <li><strong>More effective communication:</strong> The shared language fosters better collaboration between developers and domain experts.</li>
      </ul>
      <h2>Identifying Bounded Contexts</h2>
      <p>As a software engineer, there are several ways to identify bounded contexts in DDD. Here are some key approaches:</p>
      <h3>Understanding the Domain and its Complexity</h3>
      <ul>
         <li><strong>Domain Analysis:</strong> Deep dive into the problem space. This involves discussions with domain experts to understand the core functionalities, processes, and any existing organizational structures.</li>
         <li><strong>Complexity:</strong> Identify areas of high complexity within the domain. Bounded contexts are often a good way to isolate and manage these complexities.</li>
      </ul>
      <h3>Ubiquitous Language and Team Ownership</h3>
      <ul>
         <li><strong>Conceptual Differences:</strong> Look for areas where the domain has different terminology or fundamentally different concepts. These could indicate boundaries between contexts.</li>
         <li><strong>Team Ownership:</strong> Consider how the domain aligns with your development teams. Bounded contexts can reflect natural ownership boundaries for different teams.</li>
      </ul>
      <h3>Context Mapping</h3>
      <p>This is a specific DDD pattern to identify and visualize bounded contexts. It involves:</p>
      <ul>
         <li>Identifying candidate contexts based on the above approaches.</li>
         <li>Highlighting the relationships between them (shared data, dependencies etc.)</li>
         <li>Deciding on the interaction style between contexts (e.g., Database sharing, API calls).</li>
      </ul>
      <p>Remember: There's no one-size-fits-all solution. The ideal granularity of bounded contexts depends on your specific project and its needs.</p>



      <h1 style="text-align: center;">Inventory System with Domain-Driven Design (DDD)</h1>
      <p>This document outlines a possible approach to designing an inventory system for a shoe company using Domain-Driven Design (DDD). DDD helps us model the core functionalities and terminology of the business domain into software.</p>
    
      <h2>Bounded Contexts</h2>
      <p>A core concept in DDD is the Bounded Context (BC). A BC represents a specific area of the domain with its own set of responsibilities and rules. Here, we can identify three main BCs for our inventory system:</p>
    
      <ul>
        <li>
          <h3>Product Management</h3>
          <p>This BC is focused on defining and managing information about shoe styles (brand, model, material, color, sizes).</p>
          <ul>
            <li>This BC might not be directly involved in the inventory system itself, but acts as a source of product data.</li>
          </ul>
        </li>
        <li>
          <h3>Inventory Management</h3>
          <p>This is the core BC for our system, responsible for maintaining accurate stock data.</p>
          <ul>
            <li>This BC interacts with other BCs like Order Fulfillment to fulfill orders.</li>
          </ul>
        </li>
        <li>
          <h3>Order Fulfillment</h3>
          <p>This BC processes customer orders and ensures efficient picking, packing, and shipping of shoes.</p>
          <ul>
            <li>This BC interacts with Inventory Management to retrieve stock information and fulfill orders.</li>
          </ul>
        </li>
      </ul>
    
      <h2>Ubiquitous Language</h2>
      <p>Developing a shared vocabulary (Ubiquitous Language) is crucial in DDD. Here are some key terms specific to our shoe company inventory system:</p>
    
      <ul>
        <li>Shoe: A specific style of shoe with unique attributes like brand, model, material, and color.</li>
        <li>SKU (Stock Keeping Unit): A unique identifier for a specific shoe considering size and other variations (e.g., colorway, width).</li>
        <li>Warehouse: A location for storing bulk shoe inventory.</li>
        <li>Store: A retail location selling shoes to customers.</li>
        <li>Stock Level: The quantity of a specific SKU available at a particular location.</li>
      </ul>
    
      <h2>Core Building Blocks</h2>
      <p>DDD utilizes several building blocks to model the domain. Here's how they apply to our system:</p>
    
      <h3>Entities</h3>
      <p>These are objects with a unique identity that persist over time.  In our case:</p>
      <ul>
        <li>Shoe: Represents a unique shoe style with its attributes (brand, model, material, color).</li>
        <li>SKU: Represents a specific variant of a shoe considering size and possibly other variations.</li>
      </ul>
    
      <h3>Value Objects</h3>
      <p>These are immutable objects that describe entities but don't have their own independent identity.  Examples include:</p>
      <ul>
        <li>Size: Represents a specific shoe size (e.g., US 8, EU 41).</li>
        <li>Color: Represents the color of a shoe (e.g., red, blue).</li>
        <li>Location: Represents the specific warehouse or store where inventory is held (can include address details).</li>
      </ul>
    
      <h3>Aggregates</h3>
      <p>These are groups of related entities treated as a single unit for consistency purposes.  Here:</p>
      <ul>
        <li>Inventory Item: Combines an SKU and a Location, acting as the aggregate root.  It holds the current stock level for that specific SKU at that location.</li>
      </ul>
    
      <h3>Domain Services</h3>
      <p>These are operations that implement complex business logic but don't belong to any specific entity.  Examples:</p>
      <ul>
        <li>Stock Transfer: Orchestrates the movement of inventory between warehouses or stores, updating stock levels accordingly.</li>
        <li>Low Stock Alert: Checks inventory levels and triggers alerts for SKUs nearing depletion.</li>
        <li>Receive Shipment: Processes incoming shipments of shoes, updating stock levels for received SKUs.</li>
    </ul>
  
    <p>Remember, this is a basic example, and the specific DDD elements will depend on the complexities of your shoe company's inventory system.</p>
      <h2>Acceptance Test Driven Development</h2>


      <h2>Unit Tests</h2>
      <p>Testing a small individual component, unit, module, etc in isolation to validate expected behavior</p>
      <p>Java uses Junit, and Mockito for stubbing and mocking out external calls.</p>
      <p>It is not a unit test if it (as per Michael Feathers):</p>
      <ul>
        <li>Talks to a db</li>
        <li>Communicates across the network</li>
        <li>Touches the file system</li>
        <li>If it cant run at the same time as any of your other unit tests</li>
        <li>You have to do special things to your enviornment in order to get it to work</li>
      </ul>


      <h2>Integration Tests</h2>
      <ul>
        <li>Testing components together, those components being already unit tested. How they work together as a whole.</li>
        <li>you dont want to use mocks at this part.</li>
        <li>Prior to end to end tests</li>
        <li>Brick vs Wall</li>
      </ul>




      <h2>Functional Testing</h2>
      <p>Tests a given feature of an application from the perspective of the user/according to specifications</p>
      <p>Like integration testing, requires actual integration of the user.</p>
      <p>Types of Functional Tests:</p>
      <ul>
        <li>Smoke Testing: AKA Build Verification Testing or Confidence Testing, makes sure the new build is bug free or not.</li>
        <ul>
            <li>Basic tests to ensure core functionalities work after a new build or minor changes</li>
        </ul>
        <li>Sanity Testing: AKA Sanity Check Testing. Done before regression testing. A deeper dive into areas impacted by changes.</li>
        <ul>    
            <li>Checks critical features to confirm the software is stable enough for further testing</li>
            <li>Checks critical functionalities before in depth testing</li>
            <li>If Smoke is Breadth, Sanity is Depth</li>
            <li>A in depth type of white box testing</li>
        </ul>
        <li>Regression Testing: Ensures existing functionalities havent broken after code changes.</li>
        <li>API Testing</li>
        <li>GUI Testing</li>
      </ul>
      <h2>End to End (E2E) Tests</h2>
      <ul>
        <li>Horizontal and Vertical</li>
      </ul>

      <h2>Black Box Testing</h2>
      <h2>White Box Testing</h2>

      <h2>Automation Testing</h2>
      <ul>
        <li>Using software tools to automate a human driven manual process of reviewing and validating a software product</li>
        <li></li>
      </ul>

      <h2>Extreme Programming</h2>
      <h2>Stateless</h2>
      <h2></h2>



   </body>
</html>